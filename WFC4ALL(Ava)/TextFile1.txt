        public Form1() {
            infoGraphicPB.Visible = false;
            closeButton.Visible = false;
            tabSelection_SelectedIndexChanged(tabSelection, null);
        }

        protected override void OnKeyDown(KeyEventArgs e) {
            // ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
            switch (e.KeyData) {
                case Keys.Left:
                case Keys.Delete:
                case Keys.Back:
                    if (infoClicked) {
                        infoButton_Click(null, e);
                    } else {
                        backButton_Click(null, e);
                    }

                    e.Handled = true;
                    break;
                case Keys.Right:
                    advanceButton_Click(null, e);
                    e.Handled = true;
                    break;
                case Keys.PageDown:
                case Keys.PageUp:
                case Keys.Up:
                case Keys.Down:
                    e.Handled = true;
                    break;
                case Keys.Space:
                case Keys.P:
                    animateButton_Click(null, e);
                    e.Handled = true;
                    break;
                case Keys.S:
                case Keys.M:
                    markerButton_Click(null, e);
                    e.Handled = true;
                    break;
                case Keys.E:
                    exportButton_Click(null, e);
                    e.Handled = true;
                    break;
                case Keys.L:
                    revertMarkerButton_Click(null, e);
                    e.Handled = true;
                    break;
                case Keys.R:
                    executeButton_Click(null, e);
                    e.Handled = true;
                    break;
                case Keys.Escape:
                    if (infoClicked) {
                        infoButton_Click(null, e);
                    }

                    e.Handled = true;
                    break;
                default:
                    base.OnKeyDown(e);
                    break;
            }
        }

        /* ------------------------------------------------------------------------
         * Button Click Functions
         * ------------------------------------------------------------------------ */

        private void executeButton_Click(object sender, EventArgs e) {
            if (changingIndex) {
                return;
            }

            try {
                (Bitmap result2, bool _) = inputManager.initAndRunWfcDB(true, getStepAmount());
                while (result2 == null) {
                    (result2, _) = inputManager.initAndRunWfcDB(true, getStepAmount());
                }

                try {
                    resultPB.Image = inputManager.resizeBitmap(result2,
                        Math.Min(initOutHeight / (float) result2.Height, initOutWidth / (float) result.Width));
                } catch (Exception exception) {
#if (DEBUG)
                    Console.WriteLine(exception);
#endif
                }

                result = new Bitmap(result2);
            } catch (Exception exception) {
#if (DEBUG)
                Console.WriteLine(exception);
#endif
                resultPB.Image = InputManager.getImage("NoResultFound");
            }
        }

        private void advanceButton_Click(object sender, EventArgs e) {
            int now = DateTime.Now.Millisecond;

            if (sender == null && now - lastRanForced <= 50) {
                lastRanForced = now;
                return;
            }

            try {
                (Bitmap result2, bool finished) = inputManager.initAndRunWfcDB(false, getStepAmount());
                if (finished) {
                    return;
                }

                resultPB.Image = inputManager.resizeBitmap(result2,
                    Math.Min(initOutHeight / (float) result2.Height, initOutWidth / (float) result2.Width));

                result = new Bitmap(result2);
            } catch (Exception) {
                resultPB.Image = InputManager.getImage("NoResultFound");
            }
        }

        private void backButton_Click(object sender, EventArgs e) {
            try {
                Bitmap result2 = inputManager.stepBackWfc(getStepAmount());
                resultPB.Image = inputManager.resizeBitmap(result2,
                    Math.Min(initOutHeight / (float) result2.Height, initOutWidth / (float) result2.Width));

                int curStep = inputManager.getCurrentStep();
                if (curStep < savePoints.Peek()) {
                    savePoints.Pop();
                }

                result = new Bitmap(result2);
            } catch (Exception) {
                resultPB.Image = InputManager.getImage("NoResultFound");
            }
        }

        private void animateButton_Click(object sender, EventArgs e) {
            int now = DateTime.Now.Millisecond;

            if (inputManager.isCollapsed()) {
                executeButton_Click(sender, e);
            }

            if (sender == null && now - lastRanForced <= 50) {
                lastRanForced = now;
                return;
            }

            if (animateButton.BackgroundImage.Tag == null || animateButton.BackgroundImage.Tag.Equals("Animate")) {
                lock (animationTimer) {
                    animationTimer.Interval = getAnimationSpeed();
                    animationTimer.Tick += animationAnimationTimerTick;
                    animationTimer.Start();
                }

                animateButton.BackgroundImage = sender == null ? Resources.Pause : Resources.PauseHover;
                animateButton.BackgroundImage.Tag = "Pause";
            } else {
                lock (animationTimer) {
                    animationTimer.Stop();
                    animationTimer = new Timer();
                }

                animateButton.BackgroundImage = sender == null ? Resources.Animate : Resources.AnimateHover;
                animateButton.BackgroundImage.Tag = "Animate";
            }
        }

        private void modelChoice_Click(object sender, EventArgs e) {
            isChangingModels = true;
            Button btn = (Button) sender;
            string lastCat = categoryCB.Text;

            string[] catDataSource = InputManager.getCategories(modelChoice.Text.Equals("Switch to Tile Mode")
                ? "simpletiled"
                : "overlapping");
            categoryCB.DataSource = catDataSource;

            btn.Text = btn.Text.Equals("Switch to Tile Mode") ? "Switch to Smart Mode" : "Switch to Tile Mode";
            bool switchingToOverlap = btn.Text.Equals("Switch to Tile Mode");

            showRotationalOptions(switchingToOverlap);

            if (tabSelection.SelectedIndex == 2) {
                string lastImg = inputImageCB.Text;
                int catIndex = switchingToOverlap
                    ? Array.IndexOf(catDataSource, lastOverlapSelection.Item2)
                    : Array.IndexOf(catDataSource, lastSimpleSelection.Item2);
                categoryCB.SelectedIndex = catIndex;
                categoryCB.Text = switchingToOverlap ? lastOverlapSelection.Item1 : lastSimpleSelection.Item1;

                string[] images = inputManager.getImages(
                    switchingToOverlap ? "overlapping" : "simpletiled",
                    switchingToOverlap ? lastOverlapSelection.Item1 : lastSimpleSelection.Item1);

                inputImageCB.DataSource = images;
                int index = switchingToOverlap
                    ? Array.IndexOf(images, lastOverlapSelection.Item2)
                    : Array.IndexOf(images, lastSimpleSelection.Item2);
                inputImageCB.SelectedIndex = index;
                (object[] patternSizeDataSource, int i) = inputManager.getImagePatternDimensions(images[index]);
                patternSize.DataSource = patternSizeDataSource;
                patternSize.SelectedIndex = patternSize.Items.IndexOf(patternSizeDataSource[i]);

                if (switchingToOverlap) {
                    lastSimpleSelection = new Tuple<string, string>(lastCat, lastImg);
                } else {
                    lastOverlapSelection = new Tuple<string, string>(lastCat, lastImg);
                }
            }

            isChangingModels = false;

            patternSize.Refresh();
            inputImageCB.Refresh();
            categoryCB.Refresh();
            inputManager.setInputChanged("Model change");
            inputImage_SelectedIndexChanged(inputImageCB, e);
        }

        private void markerButton_Click(object sender, EventArgs e) {
            int curStep = inputManager.getCurrentStep();
            while (true) {
                if (savePoints.Count != 0 && curStep < savePoints.Peek()) {
                    savePoints.Pop();
                } else {
                    savePoints.Push(curStep);
                    return;
                }
            }
        }

        private void revertMarkerButton_Click(object sender, EventArgs e) {
            int prevTimePoint = savePoints.Count == 0 ? 0 : savePoints.Peek();
            if (inputManager.getCurrentStep() == prevTimePoint && savePoints.Count != 0) {
                savePoints.Pop();
                prevTimePoint = savePoints.Count == 0 ? 0 : savePoints.Peek();
            }

            int stepsToRevert = inputManager.getCurrentStep() - prevTimePoint;
            inputManager.setCurrentStep(prevTimePoint);
            try {
                result = inputManager.stepBackWfc(stepsToRevert);
                resultPB.Image = inputManager.resizeBitmap(result,
                    Math.Min(initOutHeight / (float) result.Height, initOutWidth / (float) result.Width));
            } catch (Exception) {
                resultPB.Image = InputManager.getImage("NoResultFound");
            }
        }

        private void infoButton_Click(object sender, EventArgs e) {
            infoClicked = !infoClicked;

            closeButton.Visible = infoClicked;
            infoGraphicPB.Visible = infoClicked;

            foreach (Control c in Controls) {
                if (c != loadingPB && c != selHeurPanel && c != pattHeurPanel && c != closeButton
                    && c != infoGraphicPB) {
                    c.Visible = !infoClicked;
                }
            }
        }

        private void closeButton_Click(object sender, EventArgs e) {
            infoButton_Click(sender, e);
        }

        private void tabSelection_SelectedIndexChanged(object sender, EventArgs e) {
            int selIndex = ((TabControl) sender).SelectedIndex; // 0 = Task1, 1 = Task2, 2 = Sandbox

            bool notTask1Selected = selIndex != 0;
            bool sandboxSelected = selIndex == 2;

            inputPanel.Visible = notTask1Selected;
            inputImage.Visible = notTask1Selected;
            inputImageCB.Visible = notTask1Selected;
            inputPaddingPB.Visible = notTask1Selected;

            categoryCB.Visible = sandboxSelected;
            category.Visible = sandboxSelected;
            patternSize.Visible = sandboxSelected;
            patternSizeLabel.Visible = sandboxSelected;
            modelChoice.Visible = sandboxSelected;

            string selectedCategory, selectedImage;
            isChangingModels = true;

            if (selIndex == 0) {
                // Fixate Coloured City -> Cat: "Worlds Top-Down", inputImage: "ColoredCity"
                selectedCategory = "Worlds Top-Down";
                selectedImage = "ColoredCity";

                outputHeightValue.Value = 80;
                outputWidthValue.Value = 80;
            } else {
                selectedCategory = "Textures";
                selectedImage = "3Bricks";

                outputHeightValue.Value = 32;
                outputWidthValue.Value = 32;
            }

            changingIndex = true;
            string[] catDataSource = InputManager.getCategories("overlapping");
            categoryCB.DataSource = catDataSource;
            int catIndex = Array.IndexOf(catDataSource, selectedCategory);
            categoryCB.SelectedIndex = catIndex;
            categoryCB.Text = selectedCategory;

            string[] images = inputManager.getImages("overlapping", selectedCategory);

            inputImageCB.DataSource = images;
            int index = Array.IndexOf(images, selectedImage);
            inputImageCB.SelectedIndex = index;

            patternSize.Refresh();
            inputImageCB.Refresh();
            categoryCB.Refresh();

            isChangingModels = false;

            inputManager.setInputChanged("Tab change");
            inputImage_SelectedIndexChanged(inputImageCB, e);
        }

        private void exportButton_Click(object sender, EventArgs e) {
            SaveFileDialog sfd = new();
            sfd.DefaultExt = @".png";
            sfd.Filter = @"JPeg Image|*.jpg";
            sfd.Title = @"Select export location & file name";

            DialogResult dialogResult = sfd.ShowDialog();
            if (dialogResult == DialogResult.OK && !sfd.FileName.Equals("")) {
                inputManager.getLatestOutput().Save(sfd.FileName, ImageFormat.Jpeg);
            }
        }

        /* ------------------------------------------------------------------------
         * Other Input Interaction Functions
         * ------------------------------------------------------------------------ */

        private static void pictureBoxMouseDown(object sender, MouseEventArgs e) {
            if ((e.Button & MouseButtons.Left) == MouseButtons.Left) {
                PictureBox pb = (PictureBox) sender;
                pb.BackColor = pb.BackColor.Equals(Color.LawnGreen) ? Color.Red : Color.LawnGreen;
            }
        }

        private void resultPB_Click(object sender, EventArgs e) {
            Point clickPos = ((PictureBox) sender).PointToClient(Cursor.Position);
            int clickX = clickPos.X, clickY = clickPos.Y, width = getOutputWidth(), height = getOutputHeight();
            int a = (int) Math.Floor((double) clickX * width / ((PictureBox) sender).Width),
                b = (int) Math.Floor((double) clickY * height / ((PictureBox) sender).Height);
#if (DEBUG)
            Console.WriteLine($@"(x:{clickX}, y:{clickY}) -> (a:{a}, b:{b})");
#endif
            //TODO CF2

            // Bitmap result2 = inputManager.setTile(a, b, 3);
            //
            // resultPB.Image = inputManager.resizeBitmap(result2,
            //     Math.Min(initOutHeight / (float) result2.Height, initOutWidth / (float) result2.Width));
        }

        private void selectionHeuristicCB_SelectedIndexChanged(object sender, EventArgs e) {
            string newValue = ((ComboBox) sender).SelectedItem.ToString();
            switch (Array.FindIndex(selectionHeuristicDataSource, x => x.Contains(newValue))) {
                case 0: // Least Entropy
                    selectionHeuristicPB.Image = Resources.Entropy;
                    selectionHeuristicDesc.Text
                        = @"Select the most logical choice based on available options, solve ties randomly";
                    InputManager.setSelectionHeuristic(SelectionHeuristic.ENTROPY);
                    break;
                case 1: // Simple
                    selectionHeuristicPB.Image = Resources.Simple;
                    selectionHeuristicDesc.Text = @"Similar to least entropy, but solve ties lexically";
                    InputManager.setSelectionHeuristic(SelectionHeuristic.SIMPLE);
                    break;
                case 2: // Lexical
                    selectionHeuristicPB.Image = Resources.Lexical;
                    selectionHeuristicDesc.Text = @"In reading order, starting left to right, top to bottom";
                    InputManager.setSelectionHeuristic(SelectionHeuristic.LEXICAL);
                    break;
                case 3: // Random
                    selectionHeuristicPB.Image = Resources.Random;
                    // ReSharper disable once LocalizableElement
                    selectionHeuristicDesc.Text = "Select randomly\nWarning, Slow!";
                    InputManager.setSelectionHeuristic(SelectionHeuristic.RANDOM);
                    break;
                case 4: // Spiral
                    selectionHeuristicPB.Image = Resources.Spiral;
                    selectionHeuristicDesc.Text = @"Select in an outwards spiral fashion";
                    InputManager.setSelectionHeuristic(SelectionHeuristic.SPIRAL);
                    break;
                case 5: // Hilbert Curve
                    selectionHeuristicPB.Image = Resources.Hilbert;
                    selectionHeuristicDesc.Text = @"Select following a space-filling path";
                    InputManager.setSelectionHeuristic(SelectionHeuristic.HILBERT);
                    break;
                default:
                    return;
            }

            selectionHeuristicDesc.Refresh();
            selectionHeuristicPB.Refresh();
            ((ComboBox) sender).Refresh();
            executeButton_Click(null, null);
        }

        private void patternHeuristicCB_SelectedIndexChanged(object sender, EventArgs e) {
            string newValue = ((ComboBox) sender).SelectedItem.ToString();
            switch (Array.FindIndex(patternHeuristicDataSource, x => x.Contains(newValue))) {
                case 0: // Weighted Choice
                    patternHeuristicPB.Image = Resources.Weighted;
                    patternHeuristicDesc.Text = @"Select the next pattern though prominence in the input image";
                    InputManager.setPatternHeuristic(PatternHeuristic.WEIGHTED);
                    break;
                case 1: // Random Choice
                    patternHeuristicPB.Image = Resources.Random;
                    patternHeuristicDesc.Text = @"Randomly select the pattern to use next";
                    InputManager.setPatternHeuristic(PatternHeuristic.RANDOM);
                    break;
                case 2: // Least Used
                    patternHeuristicPB.Image = Resources.LeastUsed;
                    patternHeuristicDesc.Text = @"Select the pattern that has been used the least so far";
                    InputManager.setPatternHeuristic(PatternHeuristic.LEAST_USED);
                    break;
                default:
                    return;
            }

            patternHeuristicDesc.Refresh();
            selectionHeuristicPB.Refresh();
            ((ComboBox) sender).Refresh();
            executeButton_Click(null, null);
        }

        private void outputHeightValue_ValueChanged(object sender, EventArgs e) {
            if (categoryCB.Text.Equals("Fonts")) {
                ((NumericUpDown) sender).Value = Math.Min(((NumericUpDown) sender).Value, 25);
            }

            executeButton_Click(sender, e);
        }

        private void inputPaddingPB_Click(object sender, EventArgs e) {
            Color c;
            Bitmap bm;
            if (inputPaddingEnabled()) {
                bm = new Bitmap(Resources.borderPaddingDisabled);
                c = Color.Red;
            } else {
                bm = new Bitmap(Resources.borderPaddingEnabled);
                c = Color.LawnGreen;
            }

            inputPaddingPB.Image = inputManager.resizePixels(inputPaddingPB, bm, 3, c, false);
            inputPaddingPB.BackColor = c;
            inputPaddingPB.Padding = new Padding(3);

            ((PictureBox) sender).Refresh();

            inputManager.setInputChanged("Input padding");
            executeButton_Click(null, null);
        }

        /* ------------------------------------------------------------------------
         * Mouse & Keyboard Interaction
         * ------------------------------------------------------------------------ */

        private void stepSizeTrackbar_Scroll(object sender, EventArgs e) {
            int value = stepSizeTrackbar.Value;
            bool instant = value == 100;

            stepSizeLabel.Text = instant ? @"Instantly generate an image" : @$"Number of steps to take: {value}";

            advanceButton.Enabled = !instant;
            backButton.Enabled = !instant;
            animateButton.Enabled = !instant;
            markerButton.Enabled = !instant;
            revertMarkerButton.Enabled = !instant;

            animateButton.BackgroundImage = instant ? Resources.AnimateDisabled : Resources.Animate;
            animateButton.BackgroundImage.Tag = "Animate";

            advanceButton.BackgroundImage = instant ? Resources.AdvanceDisabled : Resources.Advance;
            backButton.BackgroundImage = instant ? Resources.RevertDisabled : Resources.Revert;
            markerButton.BackgroundImage = instant ? Resources.SaveDisabled : Resources.Save;
            revertMarkerButton.BackgroundImage = instant ? Resources.LoadDisabled : Resources.Load;
        }

        /* ------------------------------------------------------------------------
         * Interface value retrieval
         * ------------------------------------------------------------------------ */

        private int getStepAmount() {
            int value = stepSizeTrackbar.Value;
            bool instant = value == 100;
            return instant ? -1 : value;
        }

        private int getAnimationSpeed() {
            int rawValue = animSpeedTrackbar.Value;
            return (int) Math.Exp(3.21887d + rawValue / 25d * 0.05546d);
        }

        /* ------------------------------------------------------------------------
         * Setters
         * ------------------------------------------------------------------------ */

        public void displayLoading(bool display) {
            loadingPB.Visible = display;
            loadingPB.Refresh();
        }

        /* ------------------------------------------------------------------------
         * Utils
         * ------------------------------------------------------------------------ */

        private void animationAnimationTimerTick(object sender, EventArgs e) {
            if (InvokeRequired) {
                /* Not on UI thread, reenter there... */
                BeginInvoke(new EventHandler(animationAnimationTimerTick), sender, e);
            } else {
                lock (animationTimer) {
                    /* only work when this is no reentry while we are already working */
                    if (animationTimer.Enabled) {
                        animationTimer.Stop();
                        animationTimer.Interval = getAnimationSpeed();
                        try {
                            (Bitmap result2, bool finished) = inputManager.initAndRunWfcDB(false, getStepAmount());
                            resultPB.Image = inputManager.resizeBitmap(result2,
                                Math.Min(initOutHeight / (float) result2.Height, initOutWidth / (float) result2.Width));

                            result = new Bitmap(result2);
                            resultPB.Refresh();
                            if (finished) {
                                animateButton.BackgroundImage = Resources.Animate;
                                animateButton.BackgroundImage.Tag = "Animate";
                                return;
                            }
                        } catch (Exception exception) {
#if (DEBUG)
                            Console.WriteLine(exception);
#endif
                            resultPB.Image = InputManager.getImage("NoResultFound");
                        }

                        animationTimer.Start();
                    }
                }
            }
        }

        private static Bitmap toGrayScale(Image source) {
            Bitmap grayImage = new(source.Width, source.Height, source.PixelFormat);
            grayImage.SetResolution(source.HorizontalResolution, source.VerticalResolution);

            ColorMatrix grayMatrix = new(new[] {
                new[] {.2126f, .2126f, .2126f, 0f, 0f},
                new[] {.7152f, .7152f, .7152f, 0f, 0f},
                new[] {.0722f, .0722f, .0722f, 0f, 0f},
                new[] {0f, 0f, 0f, 1f, 0f},
                new[] {0f, 0f, 0f, 0f, 1f}
            });

            using Graphics g = Graphics.FromImage(grayImage);
            using ImageAttributes attributes = new();
            attributes.SetColorMatrix(grayMatrix);
            g.DrawImage(source, new Rectangle(0, 0, source.Width, source.Height),
                0, 0, source.Width, source.Height, GraphicsUnit.Pixel, attributes);
            return grayImage;
        }

        // ReSharper disable once UnusedParameter.Local
        private static void addHover(object sender, EventArgs e, string message) {
            ToolTip toolTip = new();

            toolTip.AutoPopDelay = 5000;
            toolTip.InitialDelay = 0;
            toolTip.ReshowDelay = 500;
            toolTip.ShowAlways = true;

            if (sender.GetType() == typeof(PictureBox)) {
                toolTip.SetToolTip((PictureBox) sender, message);
            } else if (sender.GetType() == typeof(Button)) {
                toolTip.SetToolTip((Button) sender, message);
            }
        }

        public bool addPattern(Bitmap bitmap) {
            return bitMaps.addPattern(bitmap, pictureBoxMouseDown);
        }

        public bool addPattern(PatternArray pixels, List<Color> distinctColors) {
            return bitMaps.addPattern(pixels, distinctColors, pictureBoxMouseDown);
        }

        /* ------------------------------------------------------------------------
         * Miscellaneous
         * ------------------------------------------------------------------------ */

        private void inputChanged(object sender, EventArgs e) {
            if (!Visible) {
                return;
            }

            inputManager.setInputChanged(sender.GetType().ToString());
            executeButton_Click(null, null);
        }

        private void updateInputPadding() {
            if (!modelChoice.Text.Equals("Switch to Tile Mode")) {
                return;
            }

            Color c;
            Bitmap bm;
            if (inputPaddingEnabled()) {
                bm = new Bitmap(Resources.borderPaddingDisabled);
                c = Color.Red;
            } else {
                bm = new Bitmap(Resources.borderPaddingEnabled);
                c = Color.LawnGreen;
            }

            inputPaddingPB.Image = inputManager.resizePixels(inputPaddingPB, bm, 3, c, false);
            inputPaddingPB.BackColor = c;
            inputPaddingPB.Padding = new Padding(3);

            inputPaddingPB.Refresh();
        }
    }
}